#!/usr/bin/perl

# SNPcleaner02.pl
# Author: Tyler Linderoth, tylerp.linderoth@gmail.com

use strict;
use warnings;
use Getopt::Std;

my %opts = (d=>2, D=>100000, k=>1, u=>0, a=>2, Q=>10, S=>1e-4, b=>1e-100, f=>0, e=>1e-4, h=>1e-4, A=>undef,
	M=>undef, B=>undef, r=>undef, X=>undef, t=>undef, g=>undef, p=>undef, v=>undef);
getopts('d:D:k:u:a:Q:S:b:f:e:h:A:M:B:r:X:tgvp:', \%opts);
die (qq/
This scripts works with bcftools vcf file format to filter SNPs. This script is only for 
SNP filtering and will ignore INDELs. 

Usage: SNPcleaner.pl [options] <in.vcf>

Options:
	-d INT   minimum site read depth [$opts{d}]
  	-D INT   maximum site read depth [$opts{D}]
  	-k INT   min number of individuals with less than -u INT coverage (require -u and mpileup -D) [$opts{k}] 
  	-u INT   minimum individual coverage threshold used in -k (require -k and mpileup -D) [$opts{u}]
  	-a INT   minimum number of alternate alleles for site [$opts{a}]
 	-Q INT   minimum RMS mapping quality for SNPS [$opts{Q}]
 	-S FLOAT min p-value for strand bias [$opts{S}]
	-b FLOAT min p-value for base quality bias [$opts{b}]
	-f FLOAT min p-value for map quality bias [$opts{f}]
	-e FLOAT min p-value for end distance bias [$opts{e}]
	-h FLOAT min p-value for exact test of HWE [$opts{h}]
	-A FILE  outgroup fasta file (sorted from lowest to highest contig)
	-M CHAR  mutation type(s) to remove (ex. 'CT GA')
	-B CHAR  name for dumped bed file of filtered SNP positions
	-r FILE  list of contigs to exclude
	-X FILE  bed file of exonic regions (sorted from lowest to highest contig)
	-t       filter non-exonic sites (requires -X)
	-g	 filter exons with SNPs out of HWE (requires -X)
	-v	 process nonvariants
	-p CHAR  name for dumped file of sites that failed filters
Note: Some of the filters rely on annotations generated by SAMtools\/BCFtools.
	  To use the even coverage filter with options -k and -u, -D must be used with satmools mpileup.
	  It's recomended to use mpileup -I to ignore indels.
	  Characters in front of filtered sites (dumped with option -p) indicate filters that the site
	  failed to pass.
\n/) unless (@ARGV);

if ($opts{t} || $opts{g}) {
	die(qq/
option -X (exonic region bed file) required for options -t and -g
\n/) unless ($opts{X});
}

#open necessary filehandles, define variables, set initital conditions
open(BED, '>', $opts{B}) if ($opts{B});
open(FASTA, '<', $opts{A}) if ($opts{A});
open(EXON, '<', $opts{X}) if ($opts{X});
open(FAIL, '>', $opts{p}) if ($opts{p});
my $excont;
if ($opts{r}) {
    open(RMV, '<', $opts{r});
    my @contex = <RMV>;
    $excont = join "\t", @contex;
    close RMV;
    }
my ($base, @exnregion, @rmv_gene, @staging, $array_num, $bed_start, $line, @seq, @exon, @gene, @t);
if ($opts{A}) {
	$line = <FASTA>;
	@seq = split "", <FASTA>;
}
@exon = split /\s+/, <EXON> if $opts{X};
my $prev_cont = 'start';
$" = "\t"; #for formatting printed output
# The core loop
while (<>) {
    @t = split;
    if (/^#/) {
	print; next;
    }
    if ($opts{v}) {
	next if ($t[3] eq 'N'); #skip sites with unknown ref
	} else {
		next if ($t[4] eq '.' || $t[3] eq 'N'); #skip sites that are non-var or with uknown ref 
	}
my $violate; # for flagging filter violations
# skip sites that are not SNPs
	if (length($t[3]) > 1 || length($t[4]) > 1) {
		$violate = $violate . 'I';
		next;
	}
# filter specified contigs
	if ($opts{r} && $excont =~ /\b$t[0]\b/) {
		$violate = $violate . 'r';
	}
# filter sites with specified mutation type
	if ($opts{A}) {
		if ($t[4] ne '.') { # if site is variable
		   my $refalt=$t[3].$t[4]; my $altref=$t[4].$t[3];
		   if ($line !~ /\b$t[0]\b/) {
		   	do {$line = <FASTA>} until ($line =~ /\b$t[0]\b/ || eof);
			@seq = split "", <FASTA>;
			$base = $seq[($t[1]-1)];
		   } else {
			$base = $seq[($t[1]-1)];
		   }
		   if ($opts{M} =~ /(\b$refalt\b|\b$altref\b)/i) {
			my @mutype = split "", $1;
			$violate = $violate . 'M' if ($base !~ /$mutype[1]/i);
		   }	
	   }
   } 
# eveness across individuals coverage filter
# check where in vcf FORMAT the DP ID is	
	my @format = split ":",$t[8];
	my $ind_dp = 0;
	foreach (@format) {
		$ind_dp++ if ($_ ne 'DP');
		last if ($_ eq 'DP');
	}
#count how many individuals have >= $opts{u} coverage	
	my @genoinfo = @t[9 .. $#t];
	my $covcount = 0; 
	if ($ind_dp) {	# if DP is missing in vcf skip even coverage filter
		foreach (@genoinfo) {
			my @ind_info = split ":", $_;
			$covcount++ if ($ind_info[$ind_dp] >= $opts{u});
		}
	}
	$violate = $violate . 'k' if ($covcount < $opts{k});
# overall site coverage 
	my ($dp, $dp_alt);
	if ($t[7] !~ /DP4=/) {
		$violate = $violate . 'H';
	} else {
		if ($t[7] =~ /DP4=(\d+),(\d+),(\d+),(\d+)/i) {
			$dp = $1 + $2 + $3 + $4;
			$dp_alt = $3 + $4;
		}
		$violate = $violate . 'd' if ($dp < $opts{d});
		$violate = $violate . 'D' if ($dp > $opts{D});
		$violate = $violate . 'a' if ($dp_alt < $opts{a} && $t[4] ne '.');
	}	
# Root-mean-square mapping quality of covering reads
	my $mq = $1 if ($t[7] =~ /MQ=(\d+)/i);
	$violate = $violate . 'Q' if ($mq && $mq < $opts{Q});
# strand, baseQ, mapQ, and tail distance bias
	my ($strand, $baseqb, $mapqb, $tail_dist);
	if ($t[7] =~ /PV4=([^,]+),([^,]+),([^,]+),([^,;\t]+)/) {
		$strand = $1;
		$baseqb = $2;
		$mapqb = $3;
		$tail_dist = $4;
	} 
	$violate = $violate . 'S' if ($strand && $strand < $opts{S});
	$violate = $violate . 'b' if ($baseqb && $baseqb < $opts{b});
	$violate = $violate . 'f' if ($mapqb && $mapqb < $opts{f});
	$violate = $violate . 'e' if ($tail_dist && $tail_dist < $opts{e});
# Identify non-exonic regions
	undef @gene;
	if ($opts{X})  {
		if ($t[0] ne $prev_cont) { #execute when new contig in vcf is reached
			undef @exnregion;
			if ($t[0] eq $exon[0]) { # for when vcf contig matches contig in exon region list
				push @exnregion, [@exon];
				unless (eof(EXON)) {
					do {
				   		@exon = split /\s+/, <EXON>;
				   		push @exnregion, [@exon] if ($t[0] eq $exon[0]);
				   		} until ($t[0] ne $exon[0] || eof(EXON));
				   	}			 
		 	} else {  
				while ($t[0] ne $exon[0]) {
					@exon = split /\s+/, <EXON>;
				}
				push @exnregion, [@exon];
				unless (eof(EXON)) {
					do {
				   		@exon = split /\s+/, <EXON>;
				   		push @exnregion, [@exon] if ($t[0] eq $exon[0]);
				   		} until ($t[0] ne $exon[0] || eof(EXON));
				}
			}
			# identify gene, filter out position in non-exonic regions 
			my $inbounds = 0;
			foreach (@exnregion) {
				@gene = @{$_} if ($t[1] > ${$_}[1] && $t[1] <= ${$_}[2]);
				last if @gene;
				}
			$violate = $violate . 't' if ($opts{t} && @gene==0);
	        # identify gene/filter non-exonic position with $exnregion from last iteration	
		} else {  
			my $inbounds = 0;
			foreach (@exnregion) {
				@gene = @{$_} if ($t[1] > ${$_}[1] && $t[1] <= ${$_}[2]);
				last if @gene;
			}
			$violate = $violate . 't' if ($opts{t} && @gene==0);
		} 
	}
# HWE exact test
	if ($t[4] ne '.') {	
	   my %genocount = (
	  	homoa => 0,
		homob => 0,
		het => 0
		);
		foreach (@genoinfo) {
			if (/0\/0:/) {
				$genocount{homoa}++;
			} elsif (/1\/1:/) {
				$genocount{homob}++;
			} elsif (/0\/1:|1\/0:/) {
				$genocount{het}++;
			}
		}
		my $exactp = hwe_exact($genocount{het},$genocount{homoa},$genocount{homob});
		die(qq/Genotype counts less than 0\n/) if $exactp == -1;
		if ($exactp < $opts{h}) {
			$violate = $violate . "h(p=$exactp)";
			push @gene, 'HWE' if @gene;
		}
	}
# remove genes with SNPs out of HWE and stage all sites of the same contig for filtering
	push @t, $violate;
	if (@staging == 0 || $t[0] eq $prev_cont) {
		push @staging, [@t];
		push @rmv_gene, [@gene] if (@gene && $gene[-1] eq 'HWE');
		$prev_cont = $t[0];	
	} elsif (@staging && $t[0] ne $prev_cont) {
		$array_num = @staging;
		if ($array_num < 2 ) {
			if ($staging[0][-1]) {
				print FAIL "$staging[0][-1]\t@{$staging[0]}[0 .. $#{$staging[0]}-1]\n" if $opts{p};
			} else {
				print "@{$staging[0]}[0 .. $#{$staging[0]}-1]\n";
				$bed_start = $staging[0][1]-1;
				print BED "$staging[0][0]\t$bed_start\t$staging[0][1]\n";
			}
		} elsif ($array_num >= 2) {
			for (my $i = 0; $i <= $array_num-1; $i++){
					if ($opts{g} && @rmv_gene) {
						my $remove = 0;
						foreach (@rmv_gene) {
							if ($staging[$i][-1]) {
								$staging[$i][-1] = $staging[$i][-1] . 'g' if ($staging[$i][1] > ${$_}[1] && $staging[$i][1] <= ${$_}[2]);
								}
								else {
									$staging[$i][-1] = 'g' if ($staging[$i][1] > ${$_}[1] && $staging[$i][1] <= ${$_}[2]);
								}
							if ($staging[$i][-1]) {
								last if $staging[$i][-1] =~ /g/i;
							}
						}
					}
					if ($staging[$i][-1]) {
						print FAIL "$staging[$i][-1]\t@{$staging[$i]}[0 .. $#{$staging[$i]}-1]\n" if $opts{p}; 
					} else {
						print "@{$staging[$i]}[0 .. $#{$staging[$i]}-1]\n";
						$bed_start = $staging[$i][1]-1;
						print BED "$staging[$i][0]\t$bed_start\t$staging[$i][1]\n";
					}
				}
			}
		undef @staging;
		undef @rmv_gene;
		push @staging, [@t];
		push @rmv_gene, [@gene] if (@gene && $gene[-1] eq 'HWE');
		$prev_cont = $t[0];	
	} 
}

# print last staged positions
$array_num = @staging;
if ($array_num < 2 ) {
	if ($staging[0][-1]) {
		print FAIL "$staging[0][-1]\t@{$staging[0]}[0 .. $#{$staging[0]}-1]\n" if $opts{p};
	} else {
		print "@{$staging[0]}[0 .. $#{$staging[0]}-1]\n";
		$bed_start = $staging[0][1]-1;
		print BED "$staging[0][0]\t$bed_start\t$staging[0][1]\n";
	}
} elsif ($array_num >= 2) {
	for (my $i = 0; $i <= $array_num-1; $i++) {
		if ($opts{g} && @rmv_gene) {
			foreach (@rmv_gene) {
				if ($staging[$i][-1]) {
					$staging[$i][-1] = $staging[$i][-1] . 'g' if ($staging[$i][1] > ${$_}[1] && $staging[$i][1] <= ${$_}[2]);
					}
					else {
						$staging[$i][-1] = 'g' if ($staging[$i][1] > ${$_}[1] && $staging[$i][1] <= ${$_}[2]);
					}
				if ($staging[$i][-1]) {
					last if $staging[$i][-1] =~ /g/i;
				}
			}
		}
		if ($staging[$i][-1]) {
			print FAIL "$staging[$i][-1]\t@{$staging[$i]}[0 .. $#{$staging[$i]}-1]\n" if $opts{p};
		} else {
			print "@{$staging[$i]}[0 .. $#{$staging[$i]}-1]\n";
			$bed_start = $staging[$i][1]-1;
			print BED "$staging[$i][0]\t$bed_start\t$staging[$i][1]\n"; 
		}
	}
}

close BED if ($opts{B});
close FASTA if ($opts{A});
close EXON if ($opts{X});
close FAIL if ($opts{p});

		
sub hwe_exact {

# Citation:
# Implements an exact SNP test of Hardy-Weinberg Equilibrium as described in Wigginton et al. 2005
# note that probabilities are calculated from the midpoint in order to take advantage of the recurrence
# relationships recognized in Guo and Thompson (1992) in the implementation of their MCMC sampler

my ($obs_hets, $obs_homa, $obs_homb) = @_;

return(-1) if ($obs_hets < 0 || $obs_homa < 0 || $obs_homb < 0);

my $obs_homr; #rare homozygote
my $obs_homc; #commmon homozygote

my $n = $obs_homa + $obs_homb + $obs_hets; # total number genotypes

#define common and rare homozygotes

if ($obs_homa > $obs_homb) {
	$obs_homc = $obs_homa;
	$obs_homr = $obs_homb;
	} elsif ($obs_homa < $obs_homb) {
	$obs_homc = $obs_homb;
	$obs_homr = $obs_homa;
	} elsif ($obs_homa == $obs_homb) { # need to check how matching number homos affects algorithm
	$obs_homc = $obs_homa;
	$obs_homr = $obs_homb;
}

my $rare = 2 * $obs_homr + $obs_hets; # number of minor alleles

# initialize heterozygote probability array

my @probs;
for (my $i = 0; $i <= $rare; $i++) {
	$probs[$i] = 0.0;
}

# find midpoint of the minor allele count distribution

my $mid = int($rare * (2 * $n - $rare) / (2 * $n));
$mid = $mid + 1 if ( ($mid % 2) != ($rare % 2) ); # ensures number minor alleles and midpoint have parity

my $curr_hets = $mid;
my $curr_homr = ($rare - $mid) / 2;
my $curr_homc = $n - $curr_hets - $curr_homr;

$probs[$mid] = 1.0;
my $sum = $probs[$mid];

# calculate probabilities from midpoint down 

for ($curr_hets = $mid; $curr_hets > 1; $curr_hets -= 2) {
	$probs[$curr_hets - 2] = $probs[$curr_hets] * $curr_hets * ($curr_hets - 1) / 
	(4 * ($curr_homr + 1) * ($curr_homc + 1));
	$sum += $probs[$curr_hets - 2];

# 2 fewer heterozygotes for next iteration -> add one rare, one common homozygote
	$curr_homr++;
	$curr_homc++;
	}

# calculate  probabilities from midpoint up

$curr_hets = $mid;
$curr_homr = ($rare - $mid) / 2;
$curr_homc = $n - $curr_hets - $curr_homr;

for ($curr_hets = $mid; $curr_hets <= $rare - 2; $curr_hets += 2) {
	$probs[$curr_hets + 2] = $probs[$curr_hets] * 4 * $curr_homr * $curr_homc /
	(($curr_hets + 2) * ($curr_hets + 1));
	$sum += $probs[$curr_hets + 2];
	
# add 2 heterozygotes for next interation -> subtract one rare, one common homozygote
	$curr_homr--;
	$curr_homc--;
	}
for (my $i = 0; $i <= $rare; $i++) {
	$probs[$i] /= $sum;
}

# p-value calculation for hwe

my $p_hwe = 0.0;
for (my $i = 0; $i <= $rare; $i++) {
	next if ($probs[$i] > $probs[$obs_hets]);
	$p_hwe += $probs[$i];
	}
$p_hwe = 1.0 if ($p_hwe > 1);

return($p_hwe);

#alternate p-value calculation for phi/plow
#my $phi = $probs[$obs_hets];
#for (my $i = $obs_hets + 1; $i <= $rare; $i++) {
#	$phi += $probs[$i];
#}
#my $plow = $probs[$obs_hets];
#for (my $i = $obs_hets - 1; $i >= 0; $i--) {
#	$plow += $probs[$i];
#}
#my $p_hi_low;
#if ($phi < $plow) {
#	$p_hi_low = 2 * $phi;
#} else {
#	$p_hi_low = 2 * $plow
#	}

} 

 

